# Record Reference

A record aggregates releases with the same [open contracting process identifier (ocid)](identifiers.md#open-contracting-process-identifier-ocid).

There should be a single record per ocid per [distribution](https://www.w3.org/TR/vocab-dcat-2/#Class:Distribution), where a distribution might be a specific API endpoint or a specific bulk download file.

Records must be published within a [record package](packaging/record_package). 

**Note: If any conflicts are found between this text, and the text within the schema, the schema takes precedence.**

```{admonition} Browsing the schema
:class: note

This page presents the record package schema as tables. You can also download the canonical version of the record package schema as [JSON Schema](../../build/current_lang/record-package-schema.json), or view it in an [interactive browser](record).
```

```{workedexamplelist} The following worked examples are available for records
:tag: record
```

## Record structure

A record **must** contain an [ocid](identifiers.md#open-contracting-process-identifier-ocid) and one or more of:

* All [releases](#releases) about the contracting (or planning) process at the time of the record's publication.
* A [compiledRelease](#compiled-release) object, which represents the state of the contracting (or planning) process at the time of the record's publication.

A record **may** contain a [versionedRelease](#versioned-release) object, which aggregates, into a single object, all values of all fields from all releases up to the time of the record's publication. The versioned release is designed to make it easy to see how values change from one release to another, and will often be generated by data users, rather than by publishers.

````{admonition} Example
:class: hint

```{jsoninclude} ../examples/amendments/tender.json
:jsonpointer: /records/0
:title: record
```
````

```{jsonschema} ../../build/current_lang/record-schema.json
:nocrossref:
```

### Releases

Each release in a record can be provided as either a linked release or an embedded release.

#### Linked releases

A linked release follows a simple schema:

```{jsonschema} ../../build/current_lang/record-schema.json
:pointer: /definitions/LinkedRelease
```

For each `url` value, it must be possible for a consuming application to retrieve the release package at the URL and identify the release within it. Since a release package can contain multiple releases, for a linked release to identify a specific release via its `url` field, the `id` of the release must be appended to the release package URL using a fragment identifier.

The following example demonstrates the use of linked releases.

```{jsoninclude} ../examples/record_reference/linked_releases.json
:jsonpointer: /records/0
:expand: releases, tag
```

Each release's `url` consists of two parts:

* The URL of the release package that contains the release: `https://example.com/release_package.json`
* A fragment identifier (introduced by a hash mark #) whose value is the `id` of the release: `1`, `2` or `3`

Release `id` values are only required to be unique within the scope of a (contracting or planning) process: that is, within the scope of an `ocid` value. As such, a consuming application needs to use the fragment identifier in combination with the `ocid` of the record in order to identify the matching release within the release package.

#### Embedded releases

An embedded release follows the [release schema](reference). In other words, instead of linking to a release within a release package as above, that release is entirely included in the record.

The following example demonstrates the use of embedded releases.

```{jsoninclude} ../examples/amendments/tender.json
:jsonpointer: /records/0
:expand: releases,tag
:title: releases
```

#### Comparing options

The considerations are:

* Using linked releases yields smaller file sizes than using embedded releases.
* From a user's perspective, the contents of releases are easier to access as embedded releases than as linked releases (which involves the retrieval process described above).
* From a publisher's perspective, using linked releases involves publishing release packages and constructing `url` values, whereas using embedded releases doesn't.

### Compiled release

The compiled release is the latest version of all the data about a contracting (or planning) process at the time of the record's publication. In other words, it provides a snapshot of the process at a given point in time.

The compiled release follows the [release schema](reference), with the exception of any fields on which `"omitWhenMerged": true` is declared.

The process for creating a compiled release from individual releases is described in the [merging](merging) reference.

### Versioned release

A versioned release aggregates all values of all fields from all releases. For each field, it describes the history of values from the initial value to the current value at the time of the record's publication, including the `id`, `date` and `tag` of the release in which it was changed.

This versioned information is relevant to many use cases relating to contract monitoring. However, it can significantly increase file sizes. As such, publishers can consider publishing records both with and without the versioned release.

If the versioned release is not provided, third parties can generate it by processing the record's releases according to the [merging](merging) reference.

A separate, auto-generated [versioned release schema](../../build/current_lang/versioned-release-validation-schema.json) is provided for validating versioned releases within records.

The following example displays a single field's [versioned values](merging.md#versioned-values). This shows that the amount changed between the tender stage and a tender amendment, while the currency did not.

```{jsoninclude} ../examples/amendments/tender.json
:jsonpointer: /records/0/versionedRelease/tender/value
:expand: amount, currency, releaseTag
:title: versioned
```
